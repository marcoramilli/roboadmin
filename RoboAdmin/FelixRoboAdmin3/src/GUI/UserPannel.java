/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * UserPannel.java
 *
 * Created on 30-dic-2009, 17.36.05
 */

package GUI;

//import MD5.MD5;
import db.mySQL.MySQLDataBase;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;

/**
 *
 * @author Luca
 * Classe per la gestione degli user
 */
public class UserPannel extends javax.swing.JPanel {

    /** Creates new form UserPannel */
    public UserPannel() {
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        bindingGroup = new org.jdesktop.beansbinding.BindingGroup();

        RoboAdminDBPUEntityManager = java.beans.Beans.isDesignTime() ? null : javax.persistence.Persistence.createEntityManagerFactory("RoboAdminDBPU").createEntityManager();
        usersQuery = java.beans.Beans.isDesignTime() ? null : RoboAdminDBPUEntityManager.createQuery("SELECT u FROM Users u");
        usersList = java.beans.Beans.isDesignTime() ? java.util.Collections.emptyList() : org.jdesktop.observablecollections.ObservableCollections.observableList(usersQuery.getResultList());
        jSplitPaneUser = new javax.swing.JSplitPane();
        jPanelUsersx = new javax.swing.JPanel();
        jLabelId = new javax.swing.JLabel();
        jLabelUser = new javax.swing.JLabel();
        jLabelPassword = new javax.swing.JLabel();
        jTextFieldId = new javax.swing.JTextField();
        jTextFieldUser = new javax.swing.JTextField();
        jTextFieldPassword = new javax.swing.JTextField();
        jButtonNew = new javax.swing.JButton();
        jButtonDelete = new javax.swing.JButton();
        jButtonSubmit = new javax.swing.JButton();
        jPanelUserdx = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTableUsers = new javax.swing.JTable();

        setLayout(new java.awt.BorderLayout());

        jSplitPaneUser.setDividerLocation(250);

        jLabelId.setText("Id:");

        jLabelUser.setText("User:");

        jLabelPassword.setText("Password:");

        jButtonNew.setText("New");
        jButtonNew.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonNewActionPerformed(evt);
            }
        });

        jButtonDelete.setText("Delete");
        jButtonDelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonDeleteActionPerformed(evt);
            }
        });

        jButtonSubmit.setText("Submit");
        jButtonSubmit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonSubmitActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanelUsersxLayout = new javax.swing.GroupLayout(jPanelUsersx);
        jPanelUsersx.setLayout(jPanelUsersxLayout);
        jPanelUsersxLayout.setHorizontalGroup(
            jPanelUsersxLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelUsersxLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelUsersxLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelUsersxLayout.createSequentialGroup()
                        .addComponent(jButtonSubmit)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 40, Short.MAX_VALUE)
                        .addComponent(jButtonDelete)
                        .addGap(18, 18, 18)
                        .addComponent(jButtonNew))
                    .addGroup(jPanelUsersxLayout.createSequentialGroup()
                        .addGroup(jPanelUsersxLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabelPassword)
                            .addComponent(jLabelId)
                            .addComponent(jLabelUser))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelUsersxLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jTextFieldPassword)
                            .addComponent(jTextFieldUser)
                            .addComponent(jTextFieldId, javax.swing.GroupLayout.DEFAULT_SIZE, 131, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 54, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanelUsersxLayout.setVerticalGroup(
            jPanelUsersxLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelUsersxLayout.createSequentialGroup()
                .addGap(53, 53, 53)
                .addGroup(jPanelUsersxLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabelId)
                    .addComponent(jTextFieldId, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(30, 30, 30)
                .addGroup(jPanelUsersxLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabelUser)
                    .addComponent(jTextFieldUser, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(27, 27, 27)
                .addGroup(jPanelUsersxLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabelPassword)
                    .addComponent(jTextFieldPassword, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 253, Short.MAX_VALUE)
                .addGroup(jPanelUsersxLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonNew)
                    .addComponent(jButtonDelete)
                    .addComponent(jButtonSubmit))
                .addGap(19, 19, 19))
        );

        jSplitPaneUser.setLeftComponent(jPanelUsersx);

        jPanelUserdx.setLayout(new java.awt.BorderLayout());

        jTableUsers.setAutoCreateRowSorter(true);

        org.jdesktop.swingbinding.JTableBinding jTableBinding = org.jdesktop.swingbinding.SwingBindings.createJTableBinding(org.jdesktop.beansbinding.AutoBinding.UpdateStrategy.READ_WRITE, usersList, jTableUsers);
        org.jdesktop.swingbinding.JTableBinding.ColumnBinding columnBinding = jTableBinding.addColumnBinding(org.jdesktop.beansbinding.ELProperty.create("${id}"));
        columnBinding.setColumnName("Id");
        columnBinding.setColumnClass(Integer.class);
        columnBinding = jTableBinding.addColumnBinding(org.jdesktop.beansbinding.ELProperty.create("${user}"));
        columnBinding.setColumnName("User");
        columnBinding.setColumnClass(String.class);
        columnBinding = jTableBinding.addColumnBinding(org.jdesktop.beansbinding.ELProperty.create("${password}"));
        columnBinding.setColumnName("Password");
        columnBinding.setColumnClass(String.class);
        bindingGroup.addBinding(jTableBinding);
        jTableBinding.bind();
        jScrollPane1.setViewportView(jTableUsers);
        jTableUsers.getModel().addTableModelListener(new TableModelListener() {
            public void tableChanged(TableModelEvent e) {
                int row = e.getFirstRow();
                int column=e.getColumn();
                ModificaDati(row,column);
            }
        });

        jPanelUserdx.add(jScrollPane1, java.awt.BorderLayout.CENTER);

        jSplitPaneUser.setRightComponent(jPanelUserdx);

        add(jSplitPaneUser, java.awt.BorderLayout.CENTER);

        bindingGroup.bind();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonNewActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonNewActionPerformed
        // TODO add your handling code here:
        String NIds=jTextFieldId.getText();
        String NUser=jTextFieldUser.getText();
        String NPas=jTextFieldPassword.getText();
        try {
            int NId=Integer.parseInt(NIds);
            RendiPersistenteUsers(NId,NUser,NPas);
            usersListOld.add(new Users(NId, NUser, NUser));
        }
        catch(Exception e){
            new ErrorForm("ID non valido, deve essere un valore numerico");
        }
    }//GEN-LAST:event_jButtonNewActionPerformed

    private void jButtonDeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonDeleteActionPerformed
        // TODO add your handling code here:
       //l'unico campo fondamentale per la chiamata con campi è l'id gli altri possono essere null
        String ids=jTextFieldId.getText();
        String user=jTextFieldUser.getText();
        String pas=jTextFieldPassword.getText();
        int id;
        try {
            id=Integer.parseInt(ids);
            RimuoviRigaUsers(id,user,pas);
        }
        catch (NumberFormatException e)
        {
            int row=jTableUsers.getSelectedRow();
            if (row!=-1){
                RimuoviRigaUsers(row);
            }
            else{
                new ErrorForm("tupla non trovata");
            }
        }
    }//GEN-LAST:event_jButtonDeleteActionPerformed

    private void jButtonSubmitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonSubmitActionPerformed
        // TODO add your handling code here:
        Object [] dirtyRow=ModifiedRow.toArray();
        ModifiedRow.clear();
        for (int i=0; i<dirtyRow.length; i++){
            int row=Integer.parseInt(dirtyRow[i].toString());
            Object []Temp=new Object[jTableUsers.getColumnCount()];
            for (int j=0;j<jTableUsers.getColumnCount();j++){
              Temp[j]=jTableUsers.getValueAt(row, j);
            }
            String pas=Temp[2].toString();
            String user=Temp[1].toString();
            int id=-1;
            try {
                Users oldUsers=usersListOld.get(row);
                int oldid=oldUsers.getId();
                id=Integer.parseInt(Temp[0].toString());
                RendiPersistenteModifica(oldid,id,user,pas);
            }
            catch(NumberFormatException e){
                new ErrorForm(e.toString());
            }
        }
        usersListOld.clear();
        CopiaListaUsers(usersListOld, usersList);
    }//GEN-LAST:event_jButtonSubmitActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.persistence.EntityManager RoboAdminDBPUEntityManager;
    private javax.swing.JButton jButtonDelete;
    private javax.swing.JButton jButtonNew;
    private javax.swing.JButton jButtonSubmit;
    private javax.swing.JLabel jLabelId;
    private javax.swing.JLabel jLabelPassword;
    private javax.swing.JLabel jLabelUser;
    private javax.swing.JPanel jPanelUserdx;
    private javax.swing.JPanel jPanelUsersx;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSplitPane jSplitPaneUser;
    private javax.swing.JTable jTableUsers;
    private javax.swing.JTextField jTextFieldId;
    private javax.swing.JTextField jTextFieldPassword;
    private javax.swing.JTextField jTextFieldUser;
    private java.util.List<GUI.Users> usersList;
    private javax.persistence.Query usersQuery;
    private org.jdesktop.beansbinding.BindingGroup bindingGroup;
    // End of variables declaration//GEN-END:variables
    //Vartiabili di supporto per la gestione
    private Vector ModifiedRow=new Vector();
    private java.util.List<GUI.Users> usersListOld;
    private MySQLDataBase db=null;
// per ora l'md5 è disabilitato
    //    private MD5 md5;



    //=========================================METODI PRIVATI DI INIZIALIZZAZIONE

    protected void inizializza(MySQLDataBase dataBase){
        usersListOld=new ArrayList<Users>();
        CopiaListaUsers(usersListOld, usersList);
        //prepara il db log su file per ora
        db=dataBase;
//        md5=new MD5();
    }



    //=========================================METODI PRIVATI PER LA GESTIONE DELLA TABELLA
    /**
    * Tiene traccia delle righe/colonne interessate da una modifica
    *
    * @param row intero che riferisce la riga
    * @param column intero che tiene traccia della colonna
    * @return void
    */
    private void ModificaDati(int row ,int column){
        //Invocato a ogni modifica della tabella
        //se la colonna modificata è -1 vuol dire che si sta aggiungendo togliendo una riga
        if (column!=-1){
            if (!ModifiedRow.contains(row))
            ModifiedRow.add(row);
        }
    }


    /**
    * Crea un lista con i dati della tabella di supporto al di andare a operare sulla giusta tupla anche se questa è stata modificata
    *
    * @param List usersOld lista non modificata
    * @param List usersNew lista modificata
    * @return void
    */
    private void CopiaListaUsers(List<Users> usersOld, List<Users> usersNew){
         for (int i=0;i<usersNew.size();i++){
            usersOld.add(new Users(usersNew.get(i).getId(),usersNew.get(i).getUser(),usersNew.get(i).getPassword()));
        }
    }


    /**
    * Rende un nuovo utente persistente nel DB
    *
    * @param id intero con l'id da assegnare al nuovo utente
    * @param user stringa contenente il nome del nuovo utente
    * @param pas stringa contenente la password del nuovo utente
    * @return void
    */
    private void RendiPersistenteUsers(int id, String user, String pas){
        //prepara la query da mandare al db
//        String pass=null;
//            pass= md5.MD5(pas);

	String query ="INSERT INTO Users (Id, user, password) VALUES ('" + id + "','"+ user +"','"+ pas+"')";
        //esegue spedisce la query
        db.executeSqlUpdate(query);
        //AGGIUNGE LA RIGA DIRETTAMENTE ANCHE SULLA TABELLA
        Users newUsers=new Users(id,user,pas);
        usersList.add(newUsers);
        jTableUsers.repaint();
    }


     /**
    * Rimuove una tupla selezionata in base all'id inserito nel campo id dalla tabella e dal DB
    *
    * @param id intero con l'id dell'utente da rimuovere
    * @param user stringa contenente il nome dell'utente da rimuovere
    * @param pas stringa contenente la password dell'utente da rimuovere
    * @return void
    */
    private void RimuoviRigaUsers(int id, String user,String pas) {
        //preparo la query di rimozione
	String query = "DELETE FROM Users WHERE Id= '" + id +"' ";
	//eseguo la query
        db.executeSqlUpdate(query);
        //RIMUOVE LA RIGA DALLA TABELLA
        Users Rusers=new Users(id,user,pas);
        usersList.remove(Rusers);
        jTableUsers.repaint();
    }
    /**
    * Rimuove una tupla selezionata nella tabella dal DB
    * @return void
    */
    private void RimuoviRigaUsers(int row){
        Object id= jTableUsers.getValueAt(row, 0);
	//preparo la query
        String query = "DELETE FROM Users WHERE Id= '" + id +"' ";
	//eseguo la query
	db.executeSqlUpdate(query);
        //RIMUOVE LA RIGA DALLA TABELLA
        usersList.remove(row);
        jTableUsers.repaint();
    }


     /**
    * Rende le modifiche apportate alle tuple sulla tabella persistenti sul DB, la ricerca della tupla da modificare è svolta sull'id utente in particolare in base
    * all'oldId
    * @param oldId intero con l'id dell'utente da modificare preso prima di un eventuale modifica
    * @param id intero con l'id dell'utente, eventualmente modificato
    * @param user stringa contenente il nome dell'utente eventualmente modificato
    * @param pas stringa contenente la password dell'utente eventualmente modificata
    * @return void
    */
    private void RendiPersistenteModifica(int oldid, int id, String user, String pas) {
        
        String query = "UPDATE Users SET Id= '" +id+"', User= '"+ user +"', Password= '"+ pas +"' WHERE Id='"+ oldid +"' ";
        //eseguo la query
        db.executeSqlUpdate(query);
    }



}
